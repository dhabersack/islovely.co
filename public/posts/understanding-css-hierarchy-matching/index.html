<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="description" content="In order to improve your stylesheets, you first need to understand how browsers match CSS-selectors and HTML.">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">

    <title>Understanding CSS hierarchy-matching | islovely</title>

    <link rel="stylesheet" href="/style.css">
    <link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lato:400|PT+Serif:400,400italic,700|Source+Code+Pro">
    <noscript><link rel="stylesheet" href="/icons.fallback.css"></noscript>
  </head>

  <body>
    <header role="banner">
      <a href="/">islovely</a>
    </header>

    <nav role="navigation">
      <ol>
        <li><a href="/">Home</a>
        <li><a href="/projects">Projects</a>
        <li><a href="/posts">Posts</a>
        <li><a href="/about">About</a>
        <li><a href="/contact">Contact</a>
      </ol>
    </nav>

    <main role="main">


<h1>Understanding CSS hierarchy-matching</h1>

<p>To get a feel for how CSS-selectors should be written, you need to understand how browsers match them to the related markup. The following tries to give a top-level description that might not be entirely accurate but should still give you a good enough idea of how CSS and HTML get combined during rendering.</p>

<p><strong>Note:</strong> Writing this, I realized that this is probably not how it actually works, as using regular expressions to match selectors and hierarchies would obviate the need for repeated identification-cycles. Nevertheless, thinking of the process this way helps writing simpler selectors, so the model remains valid.</p>

<h2 id="finding-hierarchies">Finding hierarchies</h2>

<p>Consider a site with the following markup:</p>

<p>```</p>
<html>
  <head>
    <!-- omitted -->
  </head>

  <body>
    <header>
      <h1>Site title</h1>
    </header>

    <nav>
      <ol>
        <li>
          <a href="#">Link</a>
        </li>
        <li>
          <a href="#">Link</a>
        </li>
      </ol>
    </nav>

    <section>
      <article>
        <header>
          <h2>Article title</h2>

          <p>Date</p>
        </header>

        <p>Content</p>

        <p>Content with <a href="#">link</a></p>

        <ul>
          <li>
            <a href="#">Link</a>
          </li>
          <li>
            <a href="#">Link</a>
          </li>
        </ul>
      </article>
    </section>
  </body>
</html>
<p>```</p>

<p>When discarding the content and chaining all tags together according to their nesting, the path to each tag can be extracted:</p>

<table>
  <thead>
    <tr>
      <th>Tag</th>
      <th>Hierarchy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>html</th>
      <td>html</td>
    </tr>
    <tr>
      <th>body</th>
      <td>html body</td>
    </tr>
    <tr>
      <th>header</th>
      <td>html body header</td>
    </tr>
    <tr>
      <th>h1</th>
      <td>html body header h1</td>
    </tr>
    <tr>
      <th>nav</th>
      <td>html body nav</td>
    </tr>
    <tr>
      <th>ol</th>
      <td>html body nav ol</td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body nav ol li</td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body nav ol li a</td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body nav ol li</td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body nav ol li a</td>
    </tr>
    <tr>
      <th>section</th>
      <td>html body section</td>
    </tr>
    <tr>
      <th>article</th>
      <td>html body section article</td>
    </tr>
    <tr>
      <th>header</th>
      <td>html body section article header</td>
    </tr>
    <tr>
      <th>h2</th>
      <td>html body section article header h2</td>
    </tr>
    <tr>
      <th>p</th>
      <td>html body section article header p</td>
    </tr>
    <tr>
      <th>p</th>
      <td>html body section article p</td>
    </tr>
    <tr>
      <th>p</th>
      <td>html body section article p</td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body section article p a</td>
    </tr>
    <tr>
      <th>ul</th>
      <td>html body section article ul</td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body section article ul li</td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body section article ul li a</td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body section article ul li</td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body section article ul li a</td>
    </tr>
  </tbody>
</table>

<p>Note that some tags share the same hierarchy.</p>

<p>While each hierarchy could be used as a (bad) CSS-selector, think of them as an
attribute we add to each tag that we now match against selectors.</p>

<h2 id="matching-simple-selectors">Matching simple selectors</h2>

<p><strong>Selectors are matched to markup from right to left.</strong> Single-tag selectors are simplest and instruct the browser to ignore all elements whose hierarchy does not end in the exact tag given.</p>

<p>For example, matching the above table against the selector <code>li</code> would trim it down to just four elements:</p>

<table>
  <thead>
    <tr>
      <th>Tag</th>
      <th>Hierarchy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>li</th>
      <td>html body nav ol <strong>li</strong></td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body nav ol <strong>li</strong></td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body section article ul <strong>li</strong></td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body section article ul <strong>li</strong></td>
    </tr>
  </tbody>
</table>

<p>The browser only had to filter the initial table a single time to find these elements and can now apply the styles set with the selector.</p>

<h2 id="matching-multi-level-selectors">Matching multi-level selectors</h2>

<p>As soon as we chain selectors the browser has to iterate over intermediate results multiple times, potentially filtering them with every step.</p>

<p>When applying a rule such as <code>ul &gt; li</code>, the browser again starts at the rightmost tag and filters the hierarchy-table to end up with the same result as before:</p>

<table>
  <thead>
    <tr>
      <th>Tag</th>
      <th>Hierarchy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>li</th>
      <td>html body nav ol <strong>li</strong></td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body nav ol <strong>li</strong></td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body section article ul <strong>li</strong></td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body section article ul <strong>li</strong></td>
    </tr>
  </tbody>
</table>

<p>This list now gets filtered again to identify all <code>li</code>-tags nested <em>directly below</em> a <code>ul</code>-tag:</p>

<table>
  <thead>
    <tr>
      <th>Tag</th>
      <th>Hierarchy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>li</th>
      <td>html body section article <strong>ul &gt; li</strong></td>
    </tr>
    <tr>
      <th>li</th>
      <td>html body section article <strong>ul &gt; li</strong></td>
    </tr>
  </tbody>
</table>

<p>The more levels there are in a selector, the more times each resulting list needs to be iterated over again.</p>

<p>While extending a selector will often result in a condensed list, unnecessary extensions generate wasted filtering-cycles. In the above example, adding <code>html &gt; body &gt; section &gt; article &gt;</code> in front of the selector would force the browser to filter the result <strong>four more times without altering the list</strong> before it could assert a match.</p>

<h2 id="identification-loops">Identification loops</h2>

<p>While every level adds a new iteration over a filtered list of potentially-matching tags, some selectors require a more complex analysis of a single element’s hierarchy. While the child-selector (<code>&gt;</code>) only requires a check of the direct parent tag, a descendant-selector (space) might force the browser to walk up the entire hierarchy trying to find a match.</p>

<p>For example, <code>nav a</code> first filters out all elements whose hierarchy does not end in an <code>a</code>-tag, resulting in the following list:</p>

<table>
  <thead>
    <tr>
      <th>Tag</th>
      <th>Hierarchy</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>a</th>
      <td>html body nav ol li <strong>a</strong></td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body nav ol li <strong>a</strong></td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body section article p <strong>a</strong></td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body section article ul li <strong>a</strong></td>
    </tr>
    <tr>
      <th>a</th>
      <td>html body section article ul li <strong>a</strong></td>
    </tr>
  </tbody>
</table>

<p>When adding <code>nav</code> to the selector, the browser has to execute a more detailed analysis of each element’s hierarchy. For the first element, it has to go through the following steps:</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>Hierarchy</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>html body nav ol <strong>li a</strong></td>
      <td><code>nav</code> not found, continue&hellip;</td>
    </tr>
    <tr>
      <th>2</th>
      <td>html body nav <strong>ol</strong> li <strong>a</strong></td>
      <td><code>nav</code> not found, continue&hellip;</td>
    </tr>
    <tr>
      <th>3</th>
      <td>html body <strong>nav</strong> ol li <strong>a</strong></td>
      <td><code>nav</code> found, match</td>
    </tr>
  </tbody>
</table>

<p>The browser can stop walking up this element’s hierarchy as soon as a match is found and continue with the next element. In contrast to that, the last element from the initial list gets matched against <code>nav a</code> as follows:</p>

<table>
  <thead>
    <tr>
      <th>Iteration</th>
      <th>Hierarchy</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>html body section article ul <strong>li a</strong></td>
      <td><code>nav</code> not found, continue&hellip;</td>
    </tr>
    <tr>
      <th>2</th>
      <td>html body section article <strong>ul</strong> li <strong>a</strong></td>
      <td><code>nav</code> not found, continue&hellip;</td>
    </tr>
    <tr>
      <th>3</th>
      <td>html body section <strong>article</strong> ul li <strong>a</strong></td>
      <td><code>nav</code> not found, continue&hellip;</td>
    </tr>
    <tr>
      <th>4</th>
      <td>html body <strong>section</strong> article ul li <strong>a</strong></td>
      <td><code>nav</code> not found, continue&hellip;</td>
    </tr>
    <tr>
      <th>5</th>
      <td>html <strong>body</strong> section article ul li <strong>a</strong></td>
      <td><code>nav</code> not found, continue&hellip;</td>
    </tr>
    <tr>
      <th>6</th>
      <td><strong>html</strong> body section article ul li <strong>a</strong></td>
      <td><code>nav</code> not found, no match</td>
    </tr>
  </tbody>
</table>

<p>For elements that only match the end of a selector but not its beginning, the browser has to walk up the entire hierarchy before it can assess that the element definitely does not match.</p>

<p>In real-world examples, pages usually contain a much higher number of elements with deeper and more complex hierarchies. Since the matching-process has to be repeated for every element remaining after each filtering-step, it is best to <strong>keep nesting of markup to a minimum</strong> and <strong>use selectors that match or fail as quickly as possible</strong>.</p>

<p>You can read more recommendations on doing the latter in my post on <a href="#/posts/writing-high-performance-css">writing high-performance CSS</a>.</p>


    </main>

    <footer role="contentinfo">
        <p>
          Copyright &copy; 2014<br>
          Dom Habersack, <a href="/" title="Portfolio of Dom Habersack">islovely.co</a><br>
          
        </p>

        <ul>
          <li>
            <a href="http://github.com/dhabersack" class="logo-github">GitHub</a>
          </li>
          <li>
            <a href="http://twitter.com/dhabersack" class="logo-twitter">Twitter</a>
          </li>
        </ul>

        <form action="http://islovely.us5.list-manage.com/subscribe/post?u=fefc2ec4108769b84b68f81f7&amp;id=1e9d2ac4ec" method="post" name="mc-embedded-subscribe-form" target="_blank" novalidate>
          <p>
            Learn how to use code to solve problems on <a href="http://problemthinking.org">my newsletter</a>:
          </p>

          <input type="email" name="EMAIL" id="mce-email" placeholder="you@yourdomain.com">

          <input type="text" style="position: absolute; left: -5000px;" name="b_fefc2ec4108769b84b68f81f7_1e9d2ac4ec" value="">

          <button type="submit" name="subscribe">Sign up</button>
        </form>
      </div>
    </footer>

    <script>
    window.grunticon=function(e){if(e&&3===e.length){var t=window,n=!(!t.document.createElementNS||!t.document.createElementNS("http://www.w3.org/2000/svg","svg").createSVGRect||!document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1")||window.opera&&-1===navigator.userAgent.indexOf("Chrome")),o=function(o){var r=t.document.createElement("link"),a=t.document.getElementsByTagName("script")[0];r.rel="stylesheet",r.href=e[o&&n?0:o?1:2],a.parentNode.insertBefore(r,a)},r=new t.Image;r.onerror=function(){o(!1)},r.onload=function(){o(1===r.width&&1===r.height)},r.src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw=="}};
    grunticon(['icons.svg.css', 'icons.png.css', 'icons.fallback.css']);
    </script>

    <script>
    (function(i, s, o, g, r, a, m) {
      i['GoogleAnalyticsObject'] = r;
      i[r] = i[r] || function() {
        (i[r].q = i[r].q || []).push(arguments)
      },
      i[r].l = 1 * new Date();
      a = s.createElement(o),
      m = s.getElementsByTagName(o)[0];
      a.async = 1;
      a.src = g;
      m.parentNode.insertBefore(a, m)
    })(window, document, 'script', '//www.google-analytics.com/analytics.js', 'ga');

    ga('create', 'UA-13202125-5', 'islovely.co');
    ga('set', 'anonymizeIp', true);
    </script>
  </body>
</html>

