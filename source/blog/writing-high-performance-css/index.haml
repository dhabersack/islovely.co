---
date: 2012-12-28
description: Aside from the established best practices for reducing load times, a few things that can be done to stylesheets to make browsers render pages faster.
layout: post
title: Writing high-performance CSS
---

%p
  <strong>Disclaimer:</strong> Browsers are incredibly fast at parsing CSS,
  which makes gains through optimization marginal at best. There are a lot of
  other areas to tackle first to improve load times, like lowering the number of
  requests as well as file sizes of assets such as stylesheets, images and
  JavaScript.

%p
  Because they are not going to have a massive impact on performance,
  stylesheet-optimizations should always be <strong>motivated by readability and
  maintainability first</strong>. There are a few simple rules on how to write
  CSS that benefit these areas as well as performance without requiring major
  changes to your current workflow.

%p
  Any benefit you will see after following these rules is likely primarily due
  to ending up with smaller files. Consider the following a collection of “best
  practices” when it comes to writing not only efficient but also clean CSS.


%h3 Efficient selectors

%p
  The rule of thumb is to always <strong>use the simplest selector that
  matches</strong>, which can be achieved by applying these techniques:


%h4 Understand hierarchy-matching

%p
  If you are not sure how CSS gets applied to markup, you should first read my
  post on
  #{ link_to 'understanding CSS hierarchy-matching', '/blog/understanding-css-hierarchy-matching/' }.
  It aims at giving a top-level overview essential for understanding the
  remaining recommendations.

%p
  Once you feel comfortable with this subject, you should see why the star
  selector (<code>*</code>) should never be used: it forces the browser to
  evaluate every single element on the page without limitation.


%h4 Drop nonessential selectors

%p
  Selectors are evaluated from right to left, so make sure that the rightmost
  selector in your chain is as specific as possible. This often completely
  removes the need for some or all of the other selectors in the chain, which
  should be dropped whenever they are not absolutely required.

%p
  Elements in a selector should be omitted if they try to mimic HTML too closely
  without increasing clarity. For example, <code>table tr td</code> can be
  shortened to <code>td</code>, because every table data-tag is going to appear
  in this manner. The same applies to all other types: use only what you need to
  unambiguously identify the element you are looking for.


%h4 Favor child selectors over descendant selectors

%p
  Descendant selectors (spaces) usually perform worst because they require the
  entire hierarchy to be searched for all occurrences of the rightmost selector.
  For example, <code>p a</code> forces a browser to search all links on a page
  before checking which of them is nested in a paragraph <em>somewhere</em> in
  its hierarchy. The more of these you add, the more loops will have to be
  executed to figure out if a selector does or does not match the element(s)
  found initially.

%p
  Child selectors (<code>&gt;</code>) perform slightly better than descendant
  selectors because they only have to check one additional layer of parental
  tags for all occurrences of the element on their right side, but should still
  only be used if they cannot be avoided.


%h4 Prefer tag-less class- and ID-selectors

%p
  Class- and ID-selectors match fastest and should be used whenever possible.

%p
  Never tag-qualify when using an ID since it already is the most explicit
  selector and only tag-qualify when using a class when unavoidable.
  <code>tag#id</code> should always be <code>#id</code>, <code>tag.class</code>
  should be <code>.class</code> if possible, meaning all cases where the given
  class is only ever found with the same tag.


%h4 Use one ID per chain at most

%p
  Since an ID is unique on any given page, requiring it to appear in another
  unique element results in a wasted cycle of the rendering engine.

%p
  You can nest one ID in a page-level class (usually set on the
  <code>body</code>-tag) if it behaves differently on different pages, but
  selectors should never contain multiple IDs. In most cases, you want to drop
  as many selectors as you can left of the rightmost ID: <code>.post #content
  header #author a</code> should be <code>.post #author a</code> or
  <code>#author a</code>, depending on whether or not you need the page-level
  class.


%h4 Go with short instead of clever

%p
  The longer a selector is, the longer it will take the browser to match it to
  an element in the DOM. Selectors with fewer levels are not only easier to read
  but are also going to perform better. Always go for removing a level when
  deciding between using multiple child selectors or removing a level.


%h4 With great power&hellip;

%p
  Since classes perform second-best, adding a class of its own name to each tag
  would have a significant increase in performance in all browsers, i.e. writing
  <code>&lt;h1 class="h1"&gt;</code> so it can be selected with
  <code>.h1</code>. However, this is a maintenance-nightmare. Do not do this
  unless rendering is a major bottleneck, which is <em>very</em> unlikely.

%p
  If a selector consisting of multiple tags contains a class somewhere, a new
  class could be added to the last element and used as the only selector. For
  example, <code>.main header h1</code> could be condensed to a single class,
  with the heading gaining this class in the markup (<code>&lt;h1
  class="main-header-heading"&gt;</code>). This is going to have a negative
  effect on the markup in most cases and should only be used if safely
  applicable. Clean markup always trumps short selectors.


%h4 Examples

%p
  In accordance with the above rules, these selectors:

%pre
  :preserve
    header nav ul li a#login {}
    table &gt; thead &gt; tr &gt; th {}
    ul.navigation &gt; li a {}

%p
  can safely be rewritten as:

%pre
  :preserve
    #login {}
    thead th {}
    .navigation a {}


%h3 Efficient rules

%p
  Browser hacks relating to selectors (like <code>* html</code>) should be
  avoided because they tend to require redefinition of both the problem
  properties and all other properties, leading to duplicate code.

%p
  If hacks cannot be avoided, property hacks like the star for IE7 and earlier
  (i.e. <code>*margin: 0;</code>) and the underscore for IE6 and earlier (i.e.
  <code>_margin: 0;</code>) should be used. These hacks should be used if
  IE-filters like <code>AlphaImageLoader</code> are absolutely required and
  avoided in all other situations.

%p
  To avoid IE from slowing down a whole lot, pseudo-elements like
  <code>:hover</code> should not be applied to non-link elements.


%h3 Performance impact of CSS preprocessors

%p
  Preprocessors <strong>do not impact the performance</strong> of CSS when used
  correctly.

%p
  Writing bad stylesheets for preprocessing will result in bad stylesheets just
  the same as writing bad plain text stylesheets will. The primary concern lies
  in nesting selectors, which does increase the ability to easily find selectors
  because they can be organized to more closely mimic markup, but should never
  be nested deeper than absolutely necessary to be unambiguous.

%p
  Consider the following CSS as written in
  #{ link_to 'Sass', 'http://sass-lang.com/', :title => 'Sass - Syntactically Swesome Stylesheets' }:

%pre
  :preserve
    dl {
      overflow: hidden;

      &gt; dd {
        clear: left;
      }

      &gt; dd,
      &gt; dt {
        float: left;
        width: 50%;
      }
    }

%p
  While this makes it obvious that definition terms and definition descriptions
  are always nested in definition lists, this is the only way they <em>can</em>
  appear, so the nesting should be removed and the rules rewritten as:

%pre
  :preserve
    dd {
      clear: left;
    }

    dd,
    dt {
      float: left;
      width: 50%;
    }

    dl {
      overflow: hidden;
    }

%p
  Preprocessors do not result in a decrease in performance when respecting the
  aforementioned rules, assuming they are deployed as static assets and not
  processed client-side.

%p
  Styles should not require JavaScript to run on the client side, so all
  stylesheets running through preprocessors should be compiled and minified
  before deployment. Both Sass and
  #{ link_to 'Less', 'http://lesscss.org/', :title => 'LESS « The Dynamic Stylesheet language'}
  offer this functionality out of the box. To compress stylesheets in Sass,
  compile your files with the <code>--style compressed</code> flag set.


%h3 Stylesheet delivery

%p
  In addition to minification, stylesheets should be gzipped before delivery for
  a further decrease in filesize. Browsers have been able to deal with gzipped
  CSS-files for a long time. This is a server-side configuration (mod_gzip in
  Apache 1.3, mod_deflate in Apache 2.x).


%h3 Further reading

%p
  The information in this post has mostly been rounded up from these sources,
  which may contain additional information for those that want to learn more
  about the topic:

%ul
  %li= link_to 'Optimize browser rendering (Google Developers)', 'https://developers.google.com/speed/docs/best-practices/rendering', :title => 'Optimize browser rendering'
  %li= link_to 'CSS: Using every declaration just once (Google Developers)', 'https://developers.google.com/speed/articles/optimizing-css', :title => 'CSS: Using every declaration just once'
  %li= link_to 'Writing efficient CSS (Mozilla Developer Network)', 'http://developer.mozilla.org/en/Writing_Efficient_CSS', :title => 'Writing efficient CSS'
  %li= link_to 'High Performance CSS code design (Eddie Welker)', 'http://eddiewelker.com/2011/04/06/high-performance-css-code-design/', :title => 'High Performance CSS code design'
  %li= link_to 'Efficiently Rendering CSS (CSS-Tricks)', 'http://css-tricks.com/efficiently-rendering-css/', :title => 'Efficiently Rendering CSS'
